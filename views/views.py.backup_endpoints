from decimal import Decimal
import time
import json
import base64
import requests
from datetime import datetime

# Django Imports
from django.db import transaction as db_transaction
from django.db.models import Sum, Q
from django.utils.timezone import now
from django.shortcuts import get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.conf import settings

# Django REST Framework Imports
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework_simplejwt.authentication import JWTAuthentication

# Project imports
from clientPanel.models import BankDetails
from clientPanel.serializers import BankDetailsSerializer, CryptoDetailsSerializer
from adminPanel.models import CryptoDetails

# Cryptography Imports
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
import base64
from cryptography.hazmat.primitives.serialization import load_pem_private_key, load_pem_public_key

# Project-Specific Imports
from adminPanel.mt5.services import MT5ManagerActions
from adminPanel.models import Transaction, TradingAccount
from adminPanel.serializers import *
from adminPanel.views.views import get_client_ip


# CHEESEPAY_CONFIG = settings.CHEESEPAY_CONFIG
# MERCHANT_ID = CHEESEPAY_CONFIG["MERCHANT_ID"]
# APP_ID = CHEESEPAY_CONFIG["APP_ID"]
# PAYIN_URL = CHEESEPAY_CONFIG["PAYIN_URL"]

MERCHANT_ID="CH10001079"
APP_ID="u7b14kc4pNbc"
PAYIN_URL="https://api-cheezeepay-india.cheezeebit.com/payment/india/order/create/v1"


# PAYIN_URL = "https://test2-openapi.91fafafa.com/api/payment/india/order/create/v1"
# MERCHANT_ID = "CH10001165"
# APP_ID = "B2iwKFIM4tvo"



PRIVATE_KEY_STR = """-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOTXZMAugMindR
6FxBrkDQChsGVNuNHkC77b3akHNd0kxGMN/gzUoWlJVpYw60xWz9iycts1OY3xnY
ELmc36CxinNflJVuOMGc/0ip5p4Ih3AAquX/z1BFx6I9R1lIjr+cxXR/c3UbCAz9
FL6yAJnPoGD/fiR/qGRteVPrVXdy1N5qq8Lw8aa7WA55U+hftjJxjzUXEgM7DO/R
nQS6UVK7PNJc3MnqRKE8aMzEzOcFgApnGbe91wGDzbWerkCAWdDt1P/cgW2J3Rjr
rUaaOD28zsl6OWktUtffG688/8LOM8vOY/LETg2CCQomQDBVTDKYTsLTP+ymlPLb
J1VOidbvAgMBAAECggEAPDYIgjvQ7SQWmh3Gm1bXzMA+TfVDVOcQ/qhvIlTJjwb7
QvstxEc2SevYxbbnCmSaoE9WQnTVv8bRnKmY+sub82VUsf9EM7S18XPiic/orNWW
n2NBmI0xwQP4eokR6mbbTs6kZzRT5+1MGStOUtZxDdOhq7/tuCJ2GStxjjxWDfnD
vwqolTrAqPLxoGkjEqSP0PU7yP93ndaFNmzvM9NYbS8lxRoNPVoMczBYUEciLRRD
IiVZfwVFNv1xwOylfXMWIEJ15dAJyDYhRA6rQJZTBZudwwH/VWd2XRkb8MiJRyHk
Ur+RICcWDriZ36SdOQnFaSg58Bb+z7OzNFhPJa+aLQKBgQDoNjAo/b8oMP8j9Rmx
f5rmKTXIYuO6N0GYqP+dtFQRIGUZX1DxVUZ2TTQrx6MsVrU4tTU+33wNX9GcFyEG
LizqZXzVV4atlP1jIhZbY9xZetj2vPa97+n8FnteovTSTbFM5IyxiF4tAyHrWlJR
fwg9mRmSZL0sTAWulGWo1/ACdQKBgQDjb80pOBmAW6EpRMw2aPEIQkJM/NalZkw5
+dDxJ6Rzbr+ebvhkLwtF7uTQabvSTW6fGTB9mfyl0/sE4UPdgl6kApdt9ryPdqNs
OimCGULqdkTuKUPJ4Hs+kANIB+Js+EDC72Ibg/Pqgmn5H9pYXf+BgikRnibKyKly
Yhs2Pl1/UwKBgBDlyJFjDaL+FcLnFgyNjZcMDqbbU1j8pmBWg+tU8P0iD1lOT1SQ
cQUwzwgUifIzCRLsVMiTeLJ8c4NZR4TsnUYdRn071kgRXHL3SwsxdBpqzxj9XTMr
HyrB9A5J62jWUH2Y8AgHNVsvLCu1MeJOTSo2Vt8JR57OlWdD0zX7KLL1AoGBAI8I
wP4rSd5vwesyWTvew7dt9ER2vodGzqmncsA3LjVqcRgysgRPkcdpdn2cAYNBL1Df
hp93OG0R48wt34BvfRWoi5OcmPmgoyZtba1kNbE+sBsX2Iodo2S1LVsfmkbt2cy+
v/SOB9h0LDGA1tC8TPQl564syDi/+dD14ic7EZIBAoGAejIiFjxcR1OZmslX/AEG
+Hf4kHxTEX1/iCpWTzqmPM07byd5MhhP+/+3izeIlkmBSLdXyd0PvErkgyp+tc3c
cwx8KVbp2zOUQ7RW+plpvnchjYXvvU7z5eYKmLrTahlZ7as9bENPCL+EW/AtxxS1
e3Lb5ZMWxDtEpBG5hWZiMpg=
-----END PRIVATE KEY-----"""
PLATFORM_PUBLIC_KEY_STR = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyEeuiGnZIJydWe7yCFqtHP0RrohmcJwDkr47yfH5q3IoigufKL83w2ZSSg5emJXJ8zRytevrAt7KhgSeIqClhQr1f+whIbUrDnjHVz41hrOANB2hx/Y7nVL9EgxQlnDrLfH4Y1VP3C99WswzaEvYJcoOUuu8OY8wmhbjqXXhTM11RnflFsOKwQGMh8F6VnygzR0soLyGa6DuT/D6DkvIuprul6kXBFijx0jgksZKq7p/bBN1gzl8oKvL/AzOohdnweVxq7SrluCccSQV+QGFcpKo7/78InfbyspAYoHyJZf+JOpr9W1SHtqoiMiWAr/ZblxIm/mZjPdUo1liGcWV+wIDAQAB
-----END PUBLIC KEY-----"""



HEADERS = {
    "Content-Type": "application/json",
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36"
}

# ‚úÖ Load RSA Keys
def load_private_key(private_key_str):
    return load_pem_private_key(private_key_str.encode(), password=None)

def load_public_key(public_key_str):
    return load_pem_public_key(public_key_str.encode())

private_key = load_private_key(PRIVATE_KEY_STR)
public_key = load_public_key(PLATFORM_PUBLIC_KEY_STR)

# ‚úÖ Generate Signature
def sign_data(data, private_key):
    sign_string = "&".join(f"{key}={data[key]}" for key in sorted(data.keys()) if key != "sign" and data[key])
    signature = private_key.sign(
        sign_string.encode(),
        padding.PKCS1v15(),
        hashes.SHA256()
    )
    return base64.b64encode(signature).decode()

# ‚úÖ Verify Response Signature
def verify_signature(data, signature, public_key):
    try:
        sign_string = "&".join(f"{key}={data[key]}" for key in sorted(data.keys()) if key != "sign" and data[key])
        decoded_signature = base64.b64decode(signature)

        public_key.verify(
            decoded_signature,
            sign_string.encode(),
            padding.PKCS1v15(),
            hashes.SHA256()
        )
        return True
    except Exception as e:
        print(f"‚ùå Signature Verification Failed: {e}")
        return False

# ‚úÖ CheesePay Payment API
def pay_in(amount, phone, name, email, transactionid):
    NOTIFY_URL = "https://client.vtindex.com/client/cheesepay-notify/"
    RETURN_URL = "https://client.vtindex.com/deposit"

    data = {
        "appId": APP_ID,
        "merchantId": MERCHANT_ID,
        "mchOrderNo": str(transactionid),
        "paymentMode": "P2P",
        "amount": str(amount),
        "name": name,
        "phone": phone,
        "email": email,
        "notifyUrl": NOTIFY_URL,
        "returnUrl": RETURN_URL,
        "language": "en",
        "timestamp": int(time.time() * 1000),
    }
    data["sign"] = sign_data(data, private_key)

    response = requests.post(PAYIN_URL, json=data, headers=HEADERS)

    try:
        result = response.json()

        if result.get("code") == "000000":  # Success
            if result.get("sign") and verify_signature(result, result["sign"], public_key):
                return result
            else:
                print("‚ùå Pay-in response signature verification failed")
        else:
            print(f"‚ùå Pay-in failed: {result.get('msg', 'Unknown error')}")
            
        return None
    except Exception as e:
        print(f"‚ùå Error in Pay-in: {e}")
        return None




@method_decorator(csrf_exempt, name="dispatch")
class CheesePayNotifyView(APIView):
    permission_classes = []  # üîπ Removes authentication

    def post(self, request, *args, **kwargs):
        try:
            data = json.loads(request.body)

            # Extract parameters
            merchant_id = data.get("merchantId")
            mch_order_no = data.get("mchOrderNo")
            plat_order_no = data.get("platOrderNo")
            order_status = data.get("orderStatus")
            pay_amount = data.get("payAmount")
            amount_currency = data.get("amountCurrency")
            fee = data.get("fee")
            fee_currency = data.get("feeCurrency")
            payer_upi_id = data.get("payerUpiId", "")
            gmt_end = data.get("gmtEnd")
            received_signature = data.get("sign")

            # Verify merchant ID
            if merchant_id != settings.CHEESEPAY_CONFIG["MERCHANT_ID"]:
                return Response({"error": "Invalid merchant ID"}, status=status.HTTP_400_BAD_REQUEST)

            # Verify Signature
            if not self.verify_signature(data, received_signature):
                return Response({"error": "Signature verification failed"}, status=status.HTTP_400_BAD_REQUEST)

            # Select transaction for update (locking the row)
            with db_transaction.atomic():
                transaction = Transaction.objects.select_for_update().filter(id=mch_order_no).first()

                if not transaction:
                    return Response({"error": "Transaction not found"}, status=status.HTTP_404_NOT_FOUND)

                
                if order_status == 1:
                    if transaction.status == 'pending':
                        mt5action = MT5ManagerActions()
                        if mt5action.deposit_funds(transaction.trading_account.account_id, transaction.amount, "CheezeePay | "+str(plat_order_no)):
                            transaction.status = "approved"
                            transaction.description = "CheezeePay | "+str(plat_order_no)
                            transaction.save()
                            del mt5action
                            return Response({"message": "Payment received and processed"}, status=status.HTTP_200_OK)
                        
                        return Response({"error": "Retry"}, status=status.HTTP_400_BAD_REQUEST)

                elif order_status == 3:
                    return Response({"message": "Partial payment recorded"}, status=status.HTTP_200_OK)

                elif order_status == 2:                    
                    return Response({"message": "Refund processed"}, status=status.HTTP_200_OK)

                else:
                    return Response({"error": "Unknown order status"}, status=status.HTTP_400_BAD_REQUEST)

        except json.JSONDecodeError:
            return Response({"error": "Invalid JSON"}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            print(e)
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def verify_signature(self, data, received_signature):
        """
        Verify the signature using CheesePay's platform public key.
        """
        try:
            # Load public key
            public_key = load_pem_public_key(PLATFORM_PUBLIC_KEY_STR.encode())

            # Create sign string
            sign_string = "&".join(f"{key}={data[key]}" for key in sorted(data.keys()) if key != "sign" and data[key])

            # Decode the signature
            decoded_signature = base64.b64decode(received_signature)

            # Verify signature
            public_key.verify(
                decoded_signature,
                sign_string.encode(),
                padding.PKCS1v15(),
                hashes.SHA256(),
            )
            return True
        except Exception as e:
            print(f"Signature verification failed: {e}")
            return False

        
        
class LogoutView(APIView):
    def post(self, request):
        try:
            refresh_token = request.data.get("refresh")
            if not refresh_token:
                return Response({"detail": "Refresh token is required for logout."}, status=status.HTTP_400_BAD_REQUEST)
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response({"detail": "Successfully logged out."}, status=status.HTTP_200_OK)
        except Exception as e:
            return Response({"detail": str(e)}, status=status.HTTP_200_OK)
        
class ValidateTokenView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        """
        This endpoint is used to validate the token.
        If the user is authenticated, it returns a success message.
        """
        # Return user info along with validation message if the user is authenticated
        user_info = {
            "username": request.user.username,
            "email": request.user.email,
        }
        return Response(
            {"message": "Token is valid", "user": user_info}, status=200
        )

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_info_view(request):
    """
    This endpoint returns user info if the user is authenticated.
    If not, it returns a 401 Unauthorized response.
    """
    serializer = UserInfoSerializer(request.user)
    return Response(serializer.data, status=status.HTTP_200_OK)

class RecentTransactionsView(APIView):
    permission_classes = [IsAuthenticated]
    def get(self, request):
        user = request.user
        transactions = Transaction.objects.filter(trading_account__user=user).order_by('-created_at')[:5]
        serializer = TransactionSerializer(transactions, many=True)
        return Response(serializer.data)

class UserTradingAccountsView(APIView):
    permission_classes = [IsAuthenticated]
    def get(self, request):
        try:
            accounts = TradingAccount.objects.filter(user=request.user, account_type='standard')
            mt5_warning = None
            
            try:
                # Import MT5ManagerActions only when needed to avoid import-time errors
                from adminPanel.mt5.services import MT5ManagerActions
                mt5action = MT5ManagerActions()
                for account in accounts:
                    account.balance = mt5action.get_balance(account.account_id)
                    account.save()
            except Exception as mt5_error:
                # Handle MT5 connection issues gracefully
                mt5_warning = f"MT5 server unavailable: {str(mt5_error)}"
                # Continue with existing account data from database
                
            # Fetch accounts again to get the updated data (or original data if MT5 failed)
            accounts = TradingAccount.objects.filter(user=request.user, account_type='standard')
            serializer = TradingAccountSerializer(accounts, many=True)
            
            response_data = {
                "accounts": serializer.data,
                "mt5_status": "connected" if mt5_warning is None else "disconnected",
                "warning": mt5_warning
            }
            
            return Response(response_data, status=status.HTTP_200_OK)
        except Exception as e:
            # If we get here, it's likely a different error (not MT5 related)
            # Return the accounts with an error message
            try:
                accounts = TradingAccount.objects.filter(user=request.user, account_type='standard')
                serializer = TradingAccountSerializer(accounts, many=True)
                return Response({
                    "accounts": serializer.data,
                    "mt5_status": "disconnected",
                    "warning": f"Service error: {str(e)}"
                }, status=status.HTTP_200_OK)
            except Exception as final_error:
                return Response({"error": str(final_error)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class UserAccountsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            # Get standard trading accounts from database
            accounts = TradingAccount.objects.filter(user=request.user).exclude(account_type='prop')
            mt5_warning = None
            processed_accounts = []
            
            try:
                # Import MT5ManagerActions and process each account
                from adminPanel.mt5.services import MT5ManagerActions
                mt5action = MT5ManagerActions()
                
                for account in accounts:
                    # Verify account exists in MT5
                    try:
                        mt5_balance = mt5action.get_balance(account.account_id)
                        if mt5_balance is not False:  # Account exists in MT5
                            account.balance = mt5_balance
                            account.save()
                            processed_accounts.append(account)
                    except Exception as acc_error:
                        logger.warning(f"Failed to verify MT5 account {account.account_id}: {str(acc_error)}")
                        continue
                        
            except Exception as mt5_error:
                mt5_warning = f"MT5 server unavailable: {str(mt5_error)}"
                # Don't return any accounts if MT5 is unavailable
                processed_accounts = []
                
            # Only serialize accounts that have been verified in MT5
            serializer = TradingAccountSerializer(processed_accounts, many=True)
            
            response_data = {
                "accounts": serializer.data,
                "mt5_status": "connected" if not mt5_warning else "disconnected",
                "warning": mt5_warning
            }
            
            return Response(response_data, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Error in UserAccountsView: {str(e)}")
            return Response({
                "error": str(e),
                "accounts": [],
                "mt5_status": "disconnected",
                "warning": "Service error"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class UserDemoAccountsView(APIView):
    """
    Fetch all demo accounts belonging to the authenticated user.
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        demo_accounts = DemoAccount.objects.filter(user=request.user)
        serializer = DemoAccountSerializer(demo_accounts, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

class UserTransactionHistoryView(APIView):
    """
    View to fetch the user's transaction history (non-pending transactions).
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        transactions = Transaction.objects.filter(Q(trading_account__user=user) | Q(from_account__user=user) | Q(to_account__user=user)).exclude(status="pending").order_by("-created_at")
        serializer = TransactionSerializer(transactions, many=True)
        return Response(serializer.data)

class PendingTransactionsView(APIView):
    """
    View to fetch the user's pending transactions.
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        pending_transactions = Transaction.objects.filter(Q(trading_account__user=user) | Q(from_account__user=user) | Q(to_account__user=user), status="pending").order_by("-created_at")

        serializer = TransactionSerializer(pending_transactions, many=True)
        return Response(serializer.data)

class AvailablePackagesView(APIView):
    permission_classes = [IsAuthenticated]  

    def get(self, request):
        """
        Retrieve all available packages for authenticated users.
        """
        packages = Package.objects.all()  
        serializer = PackageSerializer(packages, many=True)
        return Response(serializer.data, status=200)


class IBStatsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user

        if not user.IB_status:
            return Response({"error": "You are not an IB user."}, status=403)

        commission_balance = user.total_earnings - user.total_commission_withdrawals
        current_month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        current_month_earnings = CommissionTransaction.objects.filter(
            ib_user=user, created_at__gte=current_month_start
        ).aggregate(total=Sum('commission_to_ib'))['total'] or 0
        earnings_per_month = CommissionTransaction.objects.filter(ib_user=user).values(
            'created_at__year', 'created_at__month'
        ).annotate(total=Sum('commission_to_ib')).order_by('created_at__year', 'created_at__month')

        earnings_per_year = CommissionTransaction.objects.filter(ib_user=user).values(
            'created_at__year'
        ).annotate(total=Sum('commission_to_ib')).order_by('created_at__year')

        earnings_per_level = CommissionTransaction.objects.filter(ib_user=user).values(
            'ib_level'
        ).annotate(total=Sum('commission_to_ib')).order_by('ib_level')

        # Earnings per client
        earnings_per_client = CommissionTransaction.objects.filter(ib_user=user).values(
            'client_user__email'
        ).annotate(total=Sum('commission_to_ib')).order_by('-total')

        stats = {
            "total_clients": len(user.get_all_clients()),
            "direct_clients": user.direct_client_count,
            "total_earnings": round(float(user.total_earnings),2),
            "total_commission_withdrawals": float(user.total_commission_withdrawals),
            "commission_balance": float(commission_balance),
            "joined_date": user.date_joined,
            "ib_signup_link": f"/referralsignup?referral={user.user_id}",
            "current_month_earnings": float(current_month_earnings),
            "earnings_per_month": list(earnings_per_month),
            "earnings_per_year": list(earnings_per_year),
            "earnings_per_level": list(earnings_per_level),
            "earnings_per_client": list(earnings_per_client),
        }

        return Response(stats)

class IBClientTreeView(APIView):
    permission_classes = [IsAuthenticated]

    def get_client_tree(self, ib_user, level=1):
        """
        Recursively fetch the client tree.
        """
        children = ib_user.clients.all()
        return {
            "id": ib_user.user_id,
            "name": f"{ib_user.first_name} {ib_user.last_name}",
            "email": ib_user.email,
            "level": level,
            "clients": [self.get_client_tree(child, level + 1) for child in children],
        }

    def get(self, request):
        user = request.user

        if not user.IB_status:
            return Response({"error": "You are not authorized to view the client tree."}, status=403)

        
        client_tree = self.get_client_tree(user)

        return Response(client_tree)

class IBCommissionTransactionsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user

        
        if not user.IB_status:
            return Response({"error": "You are not authorized to view commission transactions."}, status=403)

        
        transactions = CommissionTransaction.objects.filter(ib_user=user)
        serializer = CommissionTransactionSerializer(transactions, many=True)
        return Response(serializer.data)

class CommissionBalanceView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        if not user.IB_status:
            return Response({"error": "Unauthorized"}, status=403)

        balance = user.total_earnings - user.total_commission_withdrawals
        return Response({"withdrawable_balance": float(balance)})

class RequestWithdrawalView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        user = request.user
        amount = request.data.get("amount")
        account_id = request.data.get("account_id") 
        comment = request.data.get("comment", "")

        if not amount:
            return Response({"error": "Invalid amount"}, status=400)
        if float(amount) <= 0:
            return Response({"error": "Invalid amount"}, status=400)
        if Decimal(str(amount)) > Decimal(str(user.total_earnings)) - Decimal(str(user.total_commission_withdrawals)):
            return Response({"error": "Greater amount "+str(round(float(amount),2)) + " "+str(user.total_earnings)+" "+str(user.total_commission_withdrawals)}, status=400)
        
        amount = round(float(amount), 2)
        try:
            account = TradingAccount.objects.get(account_id=account_id, user=user)
        except TradingAccount.DoesNotExist:
            return Response({"error": "Invalid trading account selection" }, status=400)

        transaction = Transaction.objects.create(
            user=user,
            transaction_type="commission_withdrawal",
            amount=amount,
            status="pending",
            trading_account=account, 
        )

        ActivityLog.objects.create(
            user=user,
            activity=f"Requested commission withdrawal of {amount} to account {account_id} with comment: '{comment}'",
            ip_address=get_client_ip(request),
            endpoint=request.path,
            activity_type="create",
            activity_category="client",
            user_agent=request.META.get("HTTP_USER_AGENT", ""),
            timestamp=now(),
            related_object_id=transaction.id,
            related_object_type="Transaction",
        )

        return Response({"success": "Withdrawal request submitted."})
    
class CommissionTransactionsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        
        transactions = Transaction.objects.filter(
            user=user, transaction_type="commission_withdrawal"
        )
        serializer = TransactionSerializer(transactions, many=True)
        return Response(serializer.data)

class ManualDepositView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        try:
            
            mam_id = request.data.get("mam_id")
            amount = request.data.get("amount")
            proof = request.FILES.get("proof")

            
            if not mam_id or not amount or not proof:
                return Response(
                    {"error": "All fields (mam_id, amount, proof) are required."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            
            try:
                account = TradingAccount.objects.get(account_id=str(mam_id), user=request.user)
            except TradingAccount.DoesNotExist:
                return Response(
                    {"error": "Trading account not found."},
                    status=status.HTTP_404_NOT_FOUND,
                )

            
            transaction = Transaction.objects.create(
                user=request.user,
                trading_account=account,
                transaction_type="deposit_trading",
                amount=Decimal(amount),
                status="pending",
                description="Manual deposit request",
            )

            
            if proof:
                transaction.document = proof
                transaction.save()

            
            ActivityLog.objects.create(
                user=request.user,
                activity=f"Created manual deposit request of {amount} for account {mam_id}.",
                ip_address=get_client_ip(request),
                endpoint=request.path,
                activity_type="create",
                activity_category="client",
                user_agent=request.META.get("HTTP_USER_AGENT", ""),
                timestamp=now(),
                related_object_id=transaction.id,
                related_object_type="Transaction",
            )

            
            return Response(
                {"message": "Manual deposit request created successfully."},
                status=status.HTTP_201_CREATED,
            )

        except TradingAccount.DoesNotExist:
            return Response(
                {"error": "Trading account not found."},
                status=status.HTTP_404_NOT_FOUND,
            )

        except Exception as e:
            return Response(
                {"error": f"An error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
        

# ‚úÖ CheesePay Initiate View
@method_decorator(csrf_exempt, name='dispatch')
class CheesePayInitiateView(APIView):
    permission_classes = [IsAuthenticated]
    parser_classes = [JSONParser, FormParser]  # Support both JSON and form data
    authentication_classes = [JWTAuthentication]  # Explicitly set JWT auth

    def post(self, request, *args, **kwargs):
        try:
            # Debug authentication
            print(f"üîç User authenticated: {request.user.is_authenticated}")
            print(f"üîç User: {request.user}")
            print(f"üîç Request data: {request.data}")
            print(f"üîç Content type: {request.content_type}")
            print(f"üîç Authorization header: {request.META.get('HTTP_AUTHORIZATION', 'Not found')}")
            
            # Support both mam_id (legacy) and account_id parameters
            account_id = request.data.get("account_id") or request.data.get("mam_id")
            amount = request.data.get("amount_usd")
            amount_inr = request.data.get("amount_inr")
            
            print(f"üîç Parsed data - account_id: {account_id}, amount: {amount}, amount_inr: {amount_inr}")
            
            if not account_id or not amount:
                return Response(
                    {"success": False, "error": "All fields (account_id or mam_id, amount_usd) are required."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            account = get_object_or_404(TradingAccount, account_id=account_id, user=request.user)

            # Create transaction entry
            transaction = Transaction.objects.create(
                user=request.user,
                trading_account=account,
                transaction_type="deposit_trading",
                amount=Decimal(amount),
                status="pending",
                source="CheesePay",
            )

            pay_in_response = pay_in(
                amount=amount_inr,
                phone=request.user.phone_number,  
                name=request.user.first_name + request.user.last_name,  
                email=request.user.email,  
                transactionid=transaction.id
            )

            if pay_in_response and "cashierLink" in pay_in_response:
                return Response(
                    {
                        "success": True,
                        "message": "CheezePay deposit request created successfully.",
                        "payment_url": pay_in_response["cashierLink"],
                        "transaction_id": transaction.id,
                    },
                    status=status.HTTP_201_CREATED,
                )

            return Response(
                {"success": False, "error": "Failed to generate CheezePay cashier link."},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

        except TradingAccount.DoesNotExist:
            return Response(
                {"success": False, "error": "Trading account not found."},
                status=status.HTTP_404_NOT_FOUND,
            )
        except Exception as e:
            return Response(
                {"success": False, "error": f"An error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
            
            
class USDTDepositView(APIView):
    permission_classes = [IsAuthenticated]
    parser_classes = [MultiPartParser, FormParser]  

    def post(self, request, *args, **kwargs):
        try:
            mam_id = request.data.get("mam_id")
            amount = request.data.get("amount")
            proof = request.FILES.get("proof")

            
            if not mam_id or not amount or not proof:
                return Response(
                    {"error": "All fields (mam_id, amount, proof) are required."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            
            try:
                account = TradingAccount.objects.get(account_id=mam_id, user=request.user)
            except TradingAccount.DoesNotExist:
                return Response(
                    {"error": "Trading account not found."},
                    status=status.HTTP_404_NOT_FOUND,
                )

            
            transaction = Transaction.objects.create(
                user=request.user,
                trading_account=account,
                transaction_type="deposit_trading",  
                amount=Decimal(amount),
                status="pending",
                description="USDT Deposit request.",
                document=proof,
            )
            ActivityLog.objects.create(
                user=request.user,
                activity=f"Created USDT deposit request of {amount} for account {mam_id}.",
                ip_address=get_client_ip(request),
                endpoint=request.path,
                activity_type="create",
                activity_category="client",
                user_agent=request.META.get("HTTP_USER_AGENT", ""),
                timestamp=now(),
                related_object_id=transaction.id,
                related_object_type="Transaction",
            )
            
            serializer = TransactionSerializer(transaction)
            return Response(
                {"message": "USDT deposit request created successfully.", "transaction": serializer.data},
                status=status.HTTP_201_CREATED,
            )

        except Exception as e:
            return Response(
                {"error": f"An error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

class WithdrawInfoView(APIView):
    """
    Provides information about withdrawable balance and available withdrawal methods.
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, mam_id, *args, **kwargs):
        try:
            
            account = TradingAccount.objects.get(account_id=mam_id, user=request.user)

            
            withdrawable_amount = MT5ManagerActions().get_balance(int(account.account_id))

            
            bank_details = None
            crypto_details = None

            if hasattr(request.user, "bank_details"):
                bank_details = BankDetailsSerializer(request.user.bank_details).data

            if hasattr(request.user, "crypto_details"):
                crypto_details = CryptoDetailsSerializer(request.user.crypto_details).data

            return Response(
                {
                    "withdrawable_amount": withdrawable_amount,
                    "bank_details": bank_details,
                    "crypto_details": crypto_details,
                },
                status=status.HTTP_200_OK,
            )
        except TradingAccount.DoesNotExist:
            return Response(
                {"error": "Trading account not found."},
                status=status.HTTP_404_NOT_FOUND,
            )
        except Exception as e:
            return Response(
                {"error": f"An error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

class WithdrawRequestView(APIView):
    """
    Handles withdrawal requests for an account.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        try:
            mam_id = request.data.get("mam_id")
            amount = request.data.get("amount")
            method = request.data.get("method")

            if not mam_id or not amount or not method:
                return Response(
                    {"error": "mam_id, amount, and method are required."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            
            account = TradingAccount.objects.get(account_id=mam_id, user=request.user)

            
            withdrawable_amount = account.balance
            if Decimal(amount) > withdrawable_amount:
                return Response(
                    {"error": "Requested amount exceeds withdrawable balance."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            
            transaction = Transaction.objects.create(
                user=request.user,
                trading_account=account,
                transaction_type="withdraw_trading",
                amount=Decimal(amount),
                status="pending",  
                source=method.capitalize(),
                description=f"Withdrawal request via {method.capitalize()}",
            )
            ActivityLog.objects.create(
                user=request.user,
                activity=f"Submitted a withdrawal request for account {mam_id} with amount {amount} via {method.capitalize()}.",
                ip_address=get_client_ip(request),
                endpoint=request.path,
                activity_type="create",
                activity_category="client",
                user_agent=request.META.get("HTTP_USER_AGENT", ""),
                timestamp=now(),
                related_object_id=account.id,
                related_object_type="TradingAccount",
            )

            return Response(
                {"message": "Withdrawal request submitted successfully.", "transaction_id": transaction.id},
                status=status.HTTP_201_CREATED,
            )
        except TradingAccount.DoesNotExist:
            return Response(
                {"error": "Trading account not found."},
                status=status.HTTP_404_NOT_FOUND,
            )
        except Exception as e:
            return Response(
                {"error": f"An error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

class UserDetailsWithDocumentsView(APIView):
    """
    View to fetch user details along with associated proof documents.
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        
        user = request.user

        
        user_serializer = UserSerializer(user)

        
        return Response({
            "user_details": user_serializer.data
        }, status=200)

class BankDetailsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            logger.info(f"Starting bank details fetch for user: {request.user.username}")
            logger.info(f"User authenticated: {request.user.is_authenticated}")
            logger.info(f"User ID: {request.user.id}")
            
            bank_details = BankDetails.objects.get(user=request.user)
            logger.info(f"Found bank details: {bank_details}")
            
            serializer = BankDetailsSerializer(bank_details)
            logger.info(f"Serialized data: {serializer.data}")
            
            return Response({
                "status": "success",
                "message": "Bank details found",
                **serializer.data
            }, status=status.HTTP_200_OK)
            
        except BankDetails.DoesNotExist:
            logger.info(f"No bank details found for user: {request.user.username}")
            return Response({
                "status": "not_found",
                "message": "Bank details not found",
                "bank_name": None,
                "account_number": None,
                "branch_name": None,
                "ifsc_code": None,
                "bank_doc": None
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            import traceback
            logger.error(f"Error in BankDetailsView: {str(e)}")
            logger.error(f"User: {request.user.username}")
            logger.error(f"Full traceback: {traceback.format_exc()}")
            
            # Check if database connection is working
            from django.db import connection
            cursor = connection.cursor()
            try:
                cursor.execute("SELECT 1")
                logger.info("Database connection is working")
            except Exception as db_error:
                logger.error(f"Database error: {str(db_error)}")
            
            return Response(
                {
                    "error": "Failed to fetch bank details",
                    "detail": str(e),
                    "status": "error"
                },
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

class BankDetailsRequestView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        data = request.data
        serializer = BankDetailsRequestSerializer(data=data)
        if serializer.is_valid():
            serializer.save(user=request.user)
            ActivityLog.objects.create(
                user=request.user,
                activity="Submitted a bank details request.",
                ip_address=get_client_ip(request),
                endpoint=request.path,
                activity_type="create",
                activity_category="client",
                user_agent=request.META.get("HTTP_USER_AGENT", ""),
                timestamp=now(),
                related_object_id=serializer.instance.id,
                related_object_type="BankDetailsRequest",
            )

            return Response(
                {"message": "Bank details request submitted successfully."},
                status=status.HTTP_201_CREATED,
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class CryptoDetailsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        try:
            crypto_details = CryptoDetails.objects.get(user=request.user)
            serializer = CryptoDetailsSerializer(crypto_details)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except CryptoDetails.DoesNotExist:
            return Response(
                {"error": "Crypto details not found."},
                status=status.HTTP_200_OK,
            )

    def post(self, request):
        try:
            crypto_details, created = CryptoDetails.objects.update_or_create(
                user=request.user,
                defaults={
                    "wallet_address": request.data.get("wallet_address", "")
                },
            )
            serializer = CryptoDetailsSerializer(crypto_details)
            ActivityLog.objects.create(
                user=request.user,
                activity="Updated crypto details.",
                ip_address=get_client_ip(request),
                endpoint=request.path,
                activity_type="update",
                activity_category="client",
                user_agent=request.META.get("HTTP_USER_AGENT", ""),
                timestamp=now(),
                related_object_id=crypto_details.id,
                related_object_type="CryptoDetails",
            )

            return Response(
                {"message": "Crypto details updated successfully.", "data": serializer.data},
                status=status.HTTP_200_OK,
            )
        except Exception as e:
            return Response(
                {"error": f"Failed to update crypto details. {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST,
            )

class AccountSettingsView(APIView):
    def get(self, request, mam_id):
        account = get_object_or_404(TradingAccount, account_id=mam_id)
        return Response(
            {
                "current_leverage": account.leverage,
                "is_trading_enabled": account.is_trading_enabled,
            },
            status=status.HTTP_200_OK,
        )

class UpdateLeverageView(APIView):
    def post(self, request, mam_id):
        try:
            account = get_object_or_404(TradingAccount, account_id=mam_id)
            leverage = str(request.data.get("leverage"))
            if leverage not in ["1", "2", "5", "10", "20", "50", "100", "200", "500", "1000"]:
                return Response(
                    {"error": "Invalid leverage value."}, status=status.HTTP_400_BAD_REQUEST
                )
            if MT5ManagerActions().change_leverage(int(mam_id), int(leverage)):
                account.leverage = leverage
                account.save()
                ActivityLog.objects.create(
                    user=request.user,
                    activity=f"Updated leverage for account {account.account_id} to {leverage}.",
                    ip_address=get_client_ip(request),
                    endpoint=request.path,
                    activity_type="update",
                    activity_category="client",
                    user_agent=request.META.get("HTTP_USER_AGENT", ""),
                    timestamp=now(),
                    related_object_id=account.id,
                    related_object_type="TradingAccount",
                )

                return Response(
                    {"message": "Leverage updated successfully.", "leverage": account.leverage},
                    status=status.HTTP_200_OK,
                )
        except Exception as e:
            return Response({"message": str(e)},status=status.HTTP_500_INTERNAL_SERVER_ERROR,)

class ClientUpdateLeverageView(APIView):
    """
    API endpoint for clients to update their trading account leverage
    Endpoint: POST /api/update-leverage/{account_id}/
    Request body: { "leverage": "100" }
    """
    def post(self, request, account_id):
        try:
            # Get and verify account ownership
            account = get_object_or_404(TradingAccount, account_id=account_id, user=request.user)
            
            leverage = request.data.get("leverage")
            if not leverage or str(leverage) not in ["1", "2", "5", "10", "20", "50", "100", "200", "500", "1000"]:
                return Response(
                    {"error": "Invalid leverage value."}, 
                    status=status.HTTP_400_BAD_REQUEST
                )

            if MT5ManagerActions().change_leverage(int(account_id), int(leverage)):
                account.leverage = leverage
                account.save()
                
                ActivityLog.objects.create(
                    user=request.user,
                    activity=f"Updated leverage for account {account.account_id} to {leverage}.",
                    ip_address=get_client_ip(request),
                    endpoint=request.path,
                    activity_type="update",
                    activity_category="client",
                    user_agent=request.META.get("HTTP_USER_AGENT", ""),
                    timestamp=now(),
                    related_object_id=account.id,
                    related_object_type="TradingAccount",
                )

                # Return format matching what manage.js expects for handleLeverageUpdate
                return Response({
                    "success": True,
                    "message": "Leverage updated successfully",
                    "data": {
                        "leverage": leverage,
                        "account_id": account_id
                    }
                }, status=status.HTTP_200_OK)
            else:
                return Response({
                    "error": "Failed to update leverage in MT5"
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except TradingAccount.DoesNotExist:
            return Response(
                {"error": "Account not found or you don't have permission to modify it."},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class ClientUpdatePasswordView(APIView):
    """
    API endpoint for clients to update their trading account password
    Endpoint: POST /api/update-password/{account_id}/
    Request body: { "new_password": "password123" }
    """
    def post(self, request, account_id):
        try:
            # Get and verify account ownership
            account = get_object_or_404(TradingAccount, account_id=account_id, user=request.user)
            
            new_password = request.data.get("new_password")
            if not new_password or len(new_password) < 8:
                return Response(
                    {"error": "Password must be at least 8 characters long."},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            # Remove account_id from request body since it's in the URL
            if MT5ManagerActions().change_master_password(int(account_id), new_password):
                ActivityLog.objects.create(
                    user=request.user,
                    activity=f"Updated master password for account {account.account_id}.",
                    ip_address=get_client_ip(request),
                    endpoint=request.path,
                    activity_type="update",
                    activity_category="client",
                    user_agent=request.META.get("HTTP_USER_AGENT", ""),
                    timestamp=now(),
                    related_object_id=account.id,
                    related_object_type="TradingAccount",
                )

                # Return format matching what manage.js expects for handlePasswordUpdate
                return Response({
                    "success": True,
                    "message": "Password updated successfully",
                    "data": {
                        "account_id": account_id
                    }
                }, status=status.HTTP_200_OK)
            else:
                return Response({
                    "error": "Failed to update password in MT5"
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except TradingAccount.DoesNotExist:
            return Response(
                {"error": "Account not found or you don't have permission to modify it."},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"error": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

from django.shortcuts import render, redirect
from django.contrib import messages
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def signup_view(request):
    if request.method == "POST":
        first_name = request.POST.get("firstName")
        last_name = request.POST.get("lastName")
        email = request.POST.get("email")
        phone = request.POST.get("phone")
        password = request.POST.get("password")
        confirm_password = request.POST.get("confirmPassword")
        referrer = request.POST.get("referrer")  

        if password != confirm_password:
            messages.error(request, "Passwords do not match.")
            return redirect("signup")

        if CustomUser.objects.filter(email=email).exists():
            messages.error(request, "Email is already in use.")
            return redirect("signup")
        ibuser = CustomUser.objects.get(user_id = referrer)
        if ibuser.IB_status:
            user = CustomUser.objects.create_user(
                username=email,
                first_name=first_name,
                last_name=last_name,
                email=email,
                phone_number = phone,
                password=password,
                parent_ib = ibuser,
                
            )
        else:
            user = CustomUser.objects.create_user(
                username=email,
                first_name=first_name,
                last_name=last_name,
                email=email,
                phone_number = phone,
                password=password,
            )
            
        messages.success(request, "User created successfully. Please log in.")
        return redirect("login")  # Redirect to login page after successful registration

    return render(request, "emails/signup.html")

class USDINRRateView(APIView):
    """
    API view to fetch the current USD/INR conversion rate.
    Uses exchangerate-api.com for real-time rates.
    """
    permission_classes = [AllowAny]  # Allow unauthenticated access for testing
    
    def get(self, request):  
        try:
            url = "https://v6.exchangerate-api.com/v6/f6acb5191c2b1c2636aa597f/latest/USD"
            response = requests.get(url) 
            response.raise_for_status()
            data = response.json()

            if data.get('conversion_rates') and data['conversion_rates'].get('INR'):
                inr_rate = data['conversion_rates']['INR']
                return Response({'rate': inr_rate}, status=status.HTTP_200_OK)
            else:
                return Response({'error': 'INR rate not found in API response'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except requests.exceptions.RequestException as e:
            return Response({'error': f'API request failed: {e}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except Exception as e:
            return Response({'error': f'An unexpected error occurred: {e}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# Test endpoint for debugging authentication
class AuthTestView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [JWTAuthentication]
    
    def post(self, request):
        return Response({
            "success": True,
            "user": str(request.user),
            "authenticated": request.user.is_authenticated,
            "data_received": request.data
        })